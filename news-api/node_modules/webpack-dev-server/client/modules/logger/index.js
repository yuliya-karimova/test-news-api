/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/tapable/lib/AsyncParallelBailHook.js":
/*!***********************************************************!*\
  !*** ./node_modules/tapable/lib/AsyncParallelBailHook.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var AsyncParallelBailHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(AsyncParallelBailHookCodeFactory, _HookCodeFactory);
  function AsyncParallelBailHookCodeFactory() {
    _classCallCheck(this, AsyncParallelBailHookCodeFactory);
    return _callSuper(this, AsyncParallelBailHookCodeFactory, arguments);
  }
  _createClass(AsyncParallelBailHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var onError = _ref.onError,
        onResult = _ref.onResult,
        onDone = _ref.onDone;
      var code = "";
      code += "var _results = new Array(".concat(this.options.taps.length, ");\n");
      code += "var _checkDone = function() {\n";
      code += "for(var i = 0; i < _results.length; i++) {\n";
      code += "var item = _results[i];\n";
      code += "if(item === undefined) return false;\n";
      code += "if(item.result !== undefined) {\n";
      code += onResult("item.result");
      code += "return true;\n";
      code += "}\n";
      code += "if(item.error) {\n";
      code += onError("item.error");
      code += "return true;\n";
      code += "}\n";
      code += "}\n";
      code += "return false;\n";
      code += "}\n";
      code += this.callTapsParallel({
        onError: function onError(i, err, done, doneBreak) {
          var code = "";
          code += "if(".concat(i, " < _results.length && ((_results.length = ").concat(i + 1, "), (_results[").concat(i, "] = { error: ").concat(err, " }), _checkDone())) {\n");
          code += doneBreak(true);
          code += "} else {\n";
          code += done();
          code += "}\n";
          return code;
        },
        onResult: function onResult(i, result, done, doneBreak) {
          var code = "";
          code += "if(".concat(i, " < _results.length && (").concat(result, " !== undefined && (_results.length = ").concat(i + 1, "), (_results[").concat(i, "] = { result: ").concat(result, " }), _checkDone())) {\n");
          code += doneBreak(true);
          code += "} else {\n";
          code += done();
          code += "}\n";
          return code;
        },
        onTap: function onTap(i, run, done, doneBreak) {
          var code = "";
          if (i > 0) {
            code += "if(".concat(i, " >= _results.length) {\n");
            code += done();
            code += "} else {\n";
          }
          code += run();
          if (i > 0) code += "}\n";
          return code;
        },
        onDone: onDone
      });
      return code;
    }
  }]);
  return AsyncParallelBailHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncParallelBailHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function AsyncParallelBailHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = AsyncParallelBailHook;
  hook.compile = COMPILE;
  hook._call = undefined;
  hook.call = undefined;
  return hook;
}
AsyncParallelBailHook.prototype = null;
module.exports = AsyncParallelBailHook;

/***/ }),

/***/ "./node_modules/tapable/lib/AsyncParallelHook.js":
/*!*******************************************************!*\
  !*** ./node_modules/tapable/lib/AsyncParallelHook.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var AsyncParallelHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(AsyncParallelHookCodeFactory, _HookCodeFactory);
  function AsyncParallelHookCodeFactory() {
    _classCallCheck(this, AsyncParallelHookCodeFactory);
    return _callSuper(this, AsyncParallelHookCodeFactory, arguments);
  }
  _createClass(AsyncParallelHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone;
      return this.callTapsParallel({
        onError: function onError(i, err, done, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onDone: onDone
      });
    }
  }]);
  return AsyncParallelHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncParallelHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function AsyncParallelHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = AsyncParallelHook;
  hook.compile = COMPILE;
  hook._call = undefined;
  hook.call = undefined;
  return hook;
}
AsyncParallelHook.prototype = null;
module.exports = AsyncParallelHook;

/***/ }),

/***/ "./node_modules/tapable/lib/AsyncSeriesBailHook.js":
/*!*********************************************************!*\
  !*** ./node_modules/tapable/lib/AsyncSeriesBailHook.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var AsyncSeriesBailHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(AsyncSeriesBailHookCodeFactory, _HookCodeFactory);
  function AsyncSeriesBailHookCodeFactory() {
    _classCallCheck(this, AsyncSeriesBailHookCodeFactory);
    return _callSuper(this, AsyncSeriesBailHookCodeFactory, arguments);
  }
  _createClass(AsyncSeriesBailHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        _onResult = _ref.onResult,
        resultReturns = _ref.resultReturns,
        onDone = _ref.onDone;
      return this.callTapsSeries({
        onError: function onError(i, err, next, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onResult: function onResult(i, result, next) {
          return "if(".concat(result, " !== undefined) {\n").concat(_onResult(result), "\n} else {\n").concat(next(), "}\n");
        },
        resultReturns: resultReturns,
        onDone: onDone
      });
    }
  }]);
  return AsyncSeriesBailHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncSeriesBailHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function AsyncSeriesBailHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = AsyncSeriesBailHook;
  hook.compile = COMPILE;
  hook._call = undefined;
  hook.call = undefined;
  return hook;
}
AsyncSeriesBailHook.prototype = null;
module.exports = AsyncSeriesBailHook;

/***/ }),

/***/ "./node_modules/tapable/lib/AsyncSeriesHook.js":
/*!*****************************************************!*\
  !*** ./node_modules/tapable/lib/AsyncSeriesHook.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var AsyncSeriesHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(AsyncSeriesHookCodeFactory, _HookCodeFactory);
  function AsyncSeriesHookCodeFactory() {
    _classCallCheck(this, AsyncSeriesHookCodeFactory);
    return _callSuper(this, AsyncSeriesHookCodeFactory, arguments);
  }
  _createClass(AsyncSeriesHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone;
      return this.callTapsSeries({
        onError: function onError(i, err, next, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onDone: onDone
      });
    }
  }]);
  return AsyncSeriesHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncSeriesHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function AsyncSeriesHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = AsyncSeriesHook;
  hook.compile = COMPILE;
  hook._call = undefined;
  hook.call = undefined;
  return hook;
}
AsyncSeriesHook.prototype = null;
module.exports = AsyncSeriesHook;

/***/ }),

/***/ "./node_modules/tapable/lib/AsyncSeriesLoopHook.js":
/*!*********************************************************!*\
  !*** ./node_modules/tapable/lib/AsyncSeriesLoopHook.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var AsyncSeriesLoopHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(AsyncSeriesLoopHookCodeFactory, _HookCodeFactory);
  function AsyncSeriesLoopHookCodeFactory() {
    _classCallCheck(this, AsyncSeriesLoopHookCodeFactory);
    return _callSuper(this, AsyncSeriesLoopHookCodeFactory, arguments);
  }
  _createClass(AsyncSeriesLoopHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone;
      return this.callTapsLooping({
        onError: function onError(i, err, next, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onDone: onDone
      });
    }
  }]);
  return AsyncSeriesLoopHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncSeriesLoopHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function AsyncSeriesLoopHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = AsyncSeriesLoopHook;
  hook.compile = COMPILE;
  hook._call = undefined;
  hook.call = undefined;
  return hook;
}
AsyncSeriesLoopHook.prototype = null;
module.exports = AsyncSeriesLoopHook;

/***/ }),

/***/ "./node_modules/tapable/lib/AsyncSeriesWaterfallHook.js":
/*!**************************************************************!*\
  !*** ./node_modules/tapable/lib/AsyncSeriesWaterfallHook.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var AsyncSeriesWaterfallHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(AsyncSeriesWaterfallHookCodeFactory, _HookCodeFactory);
  function AsyncSeriesWaterfallHookCodeFactory() {
    _classCallCheck(this, AsyncSeriesWaterfallHookCodeFactory);
    return _callSuper(this, AsyncSeriesWaterfallHookCodeFactory, arguments);
  }
  _createClass(AsyncSeriesWaterfallHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _this = this;
      var _onError = _ref.onError,
        onResult = _ref.onResult,
        onDone = _ref.onDone;
      return this.callTapsSeries({
        onError: function onError(i, err, next, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onResult: function onResult(i, result, next) {
          var code = "";
          code += "if(".concat(result, " !== undefined) {\n");
          code += "".concat(_this._args[0], " = ").concat(result, ";\n");
          code += "}\n";
          code += next();
          return code;
        },
        onDone: function onDone() {
          return onResult(_this._args[0]);
        }
      });
    }
  }]);
  return AsyncSeriesWaterfallHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncSeriesWaterfallHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function AsyncSeriesWaterfallHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
  var hook = new Hook(args, name);
  hook.constructor = AsyncSeriesWaterfallHook;
  hook.compile = COMPILE;
  hook._call = undefined;
  hook.call = undefined;
  return hook;
}
AsyncSeriesWaterfallHook.prototype = null;
module.exports = AsyncSeriesWaterfallHook;

/***/ }),

/***/ "./node_modules/tapable/lib/Hook.js":
/*!******************************************!*\
  !*** ./node_modules/tapable/lib/Hook.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && o[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var util = __webpack_require__(/*! util */ "./node_modules/tapable/lib/util-browser.js");
var deprecateContext = util.deprecate(function () {}, "Hook.context is deprecated and will be removed");
var CALL_DELEGATE = function CALL_DELEGATE() {
  this.call = this._createCall("sync");
  return this.call.apply(this, arguments);
};
var CALL_ASYNC_DELEGATE = function CALL_ASYNC_DELEGATE() {
  this.callAsync = this._createCall("async");
  return this.callAsync.apply(this, arguments);
};
var PROMISE_DELEGATE = function PROMISE_DELEGATE() {
  this.promise = this._createCall("promise");
  return this.promise.apply(this, arguments);
};
var Hook = /*#__PURE__*/function () {
  function Hook() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    _classCallCheck(this, Hook);
    this._args = args;
    this.name = name;
    this.taps = [];
    this.interceptors = [];
    this._call = CALL_DELEGATE;
    this.call = CALL_DELEGATE;
    this._callAsync = CALL_ASYNC_DELEGATE;
    this.callAsync = CALL_ASYNC_DELEGATE;
    this._promise = PROMISE_DELEGATE;
    this.promise = PROMISE_DELEGATE;
    this._x = undefined;
    this.compile = this.compile;
    this.tap = this.tap;
    this.tapAsync = this.tapAsync;
    this.tapPromise = this.tapPromise;
  }
  _createClass(Hook, [{
    key: "compile",
    value: function compile(options) {
      throw new Error("Abstract: should be overridden");
    }
  }, {
    key: "_createCall",
    value: function _createCall(type) {
      return this.compile({
        taps: this.taps,
        interceptors: this.interceptors,
        args: this._args,
        type: type
      });
    }
  }, {
    key: "_tap",
    value: function _tap(type, options, fn) {
      if (typeof options === "string") {
        options = {
          name: options.trim()
        };
      } else if (typeof options !== "object" || options === null) {
        throw new Error("Invalid tap options");
      }
      if (typeof options.name !== "string" || options.name === "") {
        throw new Error("Missing name for tap");
      }
      if (typeof options.context !== "undefined") {
        deprecateContext();
      }
      options = _extends({
        type: type,
        fn: fn
      }, options);
      options = this._runRegisterInterceptors(options);
      this._insert(options);
    }
  }, {
    key: "tap",
    value: function tap(options, fn) {
      this._tap("sync", options, fn);
    }
  }, {
    key: "tapAsync",
    value: function tapAsync(options, fn) {
      this._tap("async", options, fn);
    }
  }, {
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this._tap("promise", options, fn);
    }
  }, {
    key: "_runRegisterInterceptors",
    value: function _runRegisterInterceptors(options) {
      var _iterator = _createForOfIteratorHelper(this.interceptors),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var interceptor = _step.value;
          if (interceptor.register) {
            var newOptions = interceptor.register(options);
            if (newOptions !== undefined) {
              options = newOptions;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return options;
    }
  }, {
    key: "withOptions",
    value: function withOptions(options) {
      var _this = this;
      var mergeOptions = function mergeOptions(opt) {
        return _extends({}, options, typeof opt === "string" ? {
          name: opt
        } : opt);
      };
      return {
        name: this.name,
        tap: function tap(opt, fn) {
          return _this.tap(mergeOptions(opt), fn);
        },
        tapAsync: function tapAsync(opt, fn) {
          return _this.tapAsync(mergeOptions(opt), fn);
        },
        tapPromise: function tapPromise(opt, fn) {
          return _this.tapPromise(mergeOptions(opt), fn);
        },
        intercept: function intercept(interceptor) {
          return _this.intercept(interceptor);
        },
        isUsed: function isUsed() {
          return _this.isUsed();
        },
        withOptions: function withOptions(opt) {
          return _this.withOptions(mergeOptions(opt));
        }
      };
    }
  }, {
    key: "isUsed",
    value: function isUsed() {
      return this.taps.length > 0 || this.interceptors.length > 0;
    }
  }, {
    key: "intercept",
    value: function intercept(interceptor) {
      this._resetCompilation();
      this.interceptors.push(_extends({}, interceptor));
      if (interceptor.register) {
        for (var i = 0; i < this.taps.length; i++) {
          this.taps[i] = interceptor.register(this.taps[i]);
        }
      }
    }
  }, {
    key: "_resetCompilation",
    value: function _resetCompilation() {
      this.call = this._call;
      this.callAsync = this._callAsync;
      this.promise = this._promise;
    }
  }, {
    key: "_insert",
    value: function _insert(item) {
      this._resetCompilation();
      var before;
      if (typeof item.before === "string") {
        before = new Set([item.before]);
      } else if (Array.isArray(item.before)) {
        before = new Set(item.before);
      }
      var stage = 0;
      if (typeof item.stage === "number") {
        stage = item.stage;
      }
      var i = this.taps.length;
      while (i > 0) {
        i--;
        var x = this.taps[i];
        this.taps[i + 1] = x;
        var xStage = x.stage || 0;
        if (before) {
          if (before.has(x.name)) {
            before.delete(x.name);
            continue;
          }
          if (before.size > 0) {
            continue;
          }
        }
        if (xStage > stage) {
          continue;
        }
        i++;
        break;
      }
      this.taps[i] = item;
    }
  }]);
  return Hook;
}();
Object.setPrototypeOf(Hook.prototype, null);
module.exports = Hook;

/***/ }),

/***/ "./node_modules/tapable/lib/HookCodeFactory.js":
/*!*****************************************************!*\
  !*** ./node_modules/tapable/lib/HookCodeFactory.js ***!
  \*****************************************************/
/***/ (function(module) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && o[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var HookCodeFactory = /*#__PURE__*/function () {
  function HookCodeFactory(config) {
    _classCallCheck(this, HookCodeFactory);
    this.config = config;
    this.options = undefined;
    this._args = undefined;
  }
  _createClass(HookCodeFactory, [{
    key: "create",
    value: function create(options) {
      this.init(options);
      var fn;
      switch (this.options.type) {
        case "sync":
          fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
            onError: function onError(err) {
              return "throw ".concat(err, ";\n");
            },
            onResult: function onResult(result) {
              return "return ".concat(result, ";\n");
            },
            resultReturns: true,
            onDone: function onDone() {
              return "";
            },
            rethrowIfPossible: true
          }));
          break;
        case "async":
          fn = new Function(this.args({
            after: "_callback"
          }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
            onError: function onError(err) {
              return "_callback(".concat(err, ");\n");
            },
            onResult: function onResult(result) {
              return "_callback(null, ".concat(result, ");\n");
            },
            onDone: function onDone() {
              return "_callback();\n";
            }
          }));
          break;
        case "promise":
          var errorHelperUsed = false;
          var content = this.contentWithInterceptors({
            onError: function onError(err) {
              errorHelperUsed = true;
              return "_error(".concat(err, ");\n");
            },
            onResult: function onResult(result) {
              return "_resolve(".concat(result, ");\n");
            },
            onDone: function onDone() {
              return "_resolve();\n";
            }
          });
          var code = "";
          code += '"use strict";\n';
          code += this.header();
          code += "return new Promise((function(_resolve, _reject) {\n";
          if (errorHelperUsed) {
            code += "var _sync = true;\n";
            code += "function _error(_err) {\n";
            code += "if(_sync)\n";
            code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
            code += "else\n";
            code += "_reject(_err);\n";
            code += "};\n";
          }
          code += content;
          if (errorHelperUsed) {
            code += "_sync = false;\n";
          }
          code += "}));\n";
          fn = new Function(this.args(), code);
          break;
      }
      this.deinit();
      return fn;
    }
  }, {
    key: "setup",
    value: function setup(instance, options) {
      instance._x = options.taps.map(function (t) {
        return t.fn;
      });
    }

    /**
     * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
     */
  }, {
    key: "init",
    value: function init(options) {
      this.options = options;
      this._args = options.args.slice();
    }
  }, {
    key: "deinit",
    value: function deinit() {
      this.options = undefined;
      this._args = undefined;
    }
  }, {
    key: "contentWithInterceptors",
    value: function contentWithInterceptors(options) {
      var _this = this;
      if (this.options.interceptors.length > 0) {
        var onError = options.onError;
        var onResult = options.onResult;
        var onDone = options.onDone;
        var code = "";
        for (var i = 0; i < this.options.interceptors.length; i++) {
          var interceptor = this.options.interceptors[i];
          if (interceptor.call) {
            code += "".concat(this.getInterceptor(i), ".call(").concat(this.args({
              before: interceptor.context ? "_context" : undefined
            }), ");\n");
          }
        }
        code += this.content(_extends(options, {
          onError: onError && function (err) {
            var code = "";
            for (var _i = 0; _i < _this.options.interceptors.length; _i++) {
              var _interceptor = _this.options.interceptors[_i];
              if (_interceptor.error) {
                code += "".concat(_this.getInterceptor(_i), ".error(").concat(err, ");\n");
              }
            }
            code += onError(err);
            return code;
          },
          onResult: onResult && function (result) {
            var code = "";
            for (var _i2 = 0; _i2 < _this.options.interceptors.length; _i2++) {
              var _interceptor2 = _this.options.interceptors[_i2];
              if (_interceptor2.result) {
                code += "".concat(_this.getInterceptor(_i2), ".result(").concat(result, ");\n");
              }
            }
            code += onResult(result);
            return code;
          },
          onDone: onDone && function () {
            var code = "";
            for (var _i3 = 0; _i3 < _this.options.interceptors.length; _i3++) {
              var _interceptor3 = _this.options.interceptors[_i3];
              if (_interceptor3.done) {
                code += "".concat(_this.getInterceptor(_i3), ".done();\n");
              }
            }
            code += onDone();
            return code;
          }
        }));
        return code;
      } else {
        return this.content(options);
      }
    }
  }, {
    key: "header",
    value: function header() {
      var code = "";
      if (this.needContext()) {
        code += "var _context = {};\n";
      } else {
        code += "var _context;\n";
      }
      code += "var _x = this._x;\n";
      if (this.options.interceptors.length > 0) {
        code += "var _taps = this.taps;\n";
        code += "var _interceptors = this.interceptors;\n";
      }
      return code;
    }
  }, {
    key: "needContext",
    value: function needContext() {
      var _iterator = _createForOfIteratorHelper(this.options.taps),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tap = _step.value;
          if (tap.context) return true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return false;
    }
  }, {
    key: "callTap",
    value: function callTap(tapIndex, _ref) {
      var onError = _ref.onError,
        onResult = _ref.onResult,
        onDone = _ref.onDone,
        rethrowIfPossible = _ref.rethrowIfPossible;
      var code = "";
      var hasTapCached = false;
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.tap) {
          if (!hasTapCached) {
            code += "var _tap".concat(tapIndex, " = ").concat(this.getTap(tapIndex), ";\n");
            hasTapCached = true;
          }
          code += "".concat(this.getInterceptor(i), ".tap(").concat(interceptor.context ? "_context, " : "", "_tap").concat(tapIndex, ");\n");
        }
      }
      code += "var _fn".concat(tapIndex, " = ").concat(this.getTapFn(tapIndex), ";\n");
      var tap = this.options.taps[tapIndex];
      switch (tap.type) {
        case "sync":
          if (!rethrowIfPossible) {
            code += "var _hasError".concat(tapIndex, " = false;\n");
            code += "try {\n";
          }
          if (onResult) {
            code += "var _result".concat(tapIndex, " = _fn").concat(tapIndex, "(").concat(this.args({
              before: tap.context ? "_context" : undefined
            }), ");\n");
          } else {
            code += "_fn".concat(tapIndex, "(").concat(this.args({
              before: tap.context ? "_context" : undefined
            }), ");\n");
          }
          if (!rethrowIfPossible) {
            code += "} catch(_err) {\n";
            code += "_hasError".concat(tapIndex, " = true;\n");
            code += onError("_err");
            code += "}\n";
            code += "if(!_hasError".concat(tapIndex, ") {\n");
          }
          if (onResult) {
            code += onResult("_result".concat(tapIndex));
          }
          if (onDone) {
            code += onDone();
          }
          if (!rethrowIfPossible) {
            code += "}\n";
          }
          break;
        case "async":
          var cbCode = "";
          if (onResult) cbCode += "(function(_err".concat(tapIndex, ", _result").concat(tapIndex, ") {\n");else cbCode += "(function(_err".concat(tapIndex, ") {\n");
          cbCode += "if(_err".concat(tapIndex, ") {\n");
          cbCode += onError("_err".concat(tapIndex));
          cbCode += "} else {\n";
          if (onResult) {
            cbCode += onResult("_result".concat(tapIndex));
          }
          if (onDone) {
            cbCode += onDone();
          }
          cbCode += "}\n";
          cbCode += "})";
          code += "_fn".concat(tapIndex, "(").concat(this.args({
            before: tap.context ? "_context" : undefined,
            after: cbCode
          }), ");\n");
          break;
        case "promise":
          code += "var _hasResult".concat(tapIndex, " = false;\n");
          code += "var _promise".concat(tapIndex, " = _fn").concat(tapIndex, "(").concat(this.args({
            before: tap.context ? "_context" : undefined
          }), ");\n");
          code += "if (!_promise".concat(tapIndex, " || !_promise").concat(tapIndex, ".then)\n");
          code += "  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise".concat(tapIndex, " + ')');\n");
          code += "_promise".concat(tapIndex, ".then((function(_result").concat(tapIndex, ") {\n");
          code += "_hasResult".concat(tapIndex, " = true;\n");
          if (onResult) {
            code += onResult("_result".concat(tapIndex));
          }
          if (onDone) {
            code += onDone();
          }
          code += "}), function(_err".concat(tapIndex, ") {\n");
          code += "if(_hasResult".concat(tapIndex, ") throw _err").concat(tapIndex, ";\n");
          code += onError("_err".concat(tapIndex));
          code += "});\n";
          break;
      }
      return code;
    }
  }, {
    key: "callTapsSeries",
    value: function callTapsSeries(_ref2) {
      var _this2 = this;
      var _onError = _ref2.onError,
        onResult = _ref2.onResult,
        resultReturns = _ref2.resultReturns,
        onDone = _ref2.onDone,
        doneReturns = _ref2.doneReturns,
        rethrowIfPossible = _ref2.rethrowIfPossible;
      if (this.options.taps.length === 0) return onDone();
      var firstAsync = this.options.taps.findIndex(function (t) {
        return t.type !== "sync";
      });
      var somethingReturns = resultReturns || doneReturns;
      var code = "";
      var current = onDone;
      var unrollCounter = 0;
      var _loop = function _loop() {
        var i = j;
        var unroll = current !== onDone && (_this2.options.taps[i].type !== "sync" || unrollCounter++ > 20);
        if (unroll) {
          unrollCounter = 0;
          code += "function _next".concat(i, "() {\n");
          code += current();
          code += "}\n";
          current = function current() {
            return "".concat(somethingReturns ? "return " : "", "_next").concat(i, "();\n");
          };
        }
        var done = current;
        var doneBreak = function doneBreak(skipDone) {
          if (skipDone) return "";
          return onDone();
        };
        var content = _this2.callTap(i, {
          onError: function onError(error) {
            return _onError(i, error, done, doneBreak);
          },
          onResult: onResult && function (result) {
            return onResult(i, result, done, doneBreak);
          },
          onDone: !onResult && done,
          rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
        });
        current = function current() {
          return content;
        };
      };
      for (var j = this.options.taps.length - 1; j >= 0; j--) {
        _loop();
      }
      code += current();
      return code;
    }
  }, {
    key: "callTapsLooping",
    value: function callTapsLooping(_ref3) {
      var onError = _ref3.onError,
        onDone = _ref3.onDone,
        rethrowIfPossible = _ref3.rethrowIfPossible;
      if (this.options.taps.length === 0) return onDone();
      var syncOnly = this.options.taps.every(function (t) {
        return t.type === "sync";
      });
      var code = "";
      if (!syncOnly) {
        code += "var _looper = (function() {\n";
        code += "var _loopAsync = false;\n";
      }
      code += "var _loop;\n";
      code += "do {\n";
      code += "_loop = false;\n";
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.loop) {
          code += "".concat(this.getInterceptor(i), ".loop(").concat(this.args({
            before: interceptor.context ? "_context" : undefined
          }), ");\n");
        }
      }
      code += this.callTapsSeries({
        onError: onError,
        onResult: function onResult(i, result, next, doneBreak) {
          var code = "";
          code += "if(".concat(result, " !== undefined) {\n");
          code += "_loop = true;\n";
          if (!syncOnly) code += "if(_loopAsync) _looper();\n";
          code += doneBreak(true);
          code += "} else {\n";
          code += next();
          code += "}\n";
          return code;
        },
        onDone: onDone && function () {
          var code = "";
          code += "if(!_loop) {\n";
          code += onDone();
          code += "}\n";
          return code;
        },
        rethrowIfPossible: rethrowIfPossible && syncOnly
      });
      code += "} while(_loop);\n";
      if (!syncOnly) {
        code += "_loopAsync = true;\n";
        code += "});\n";
        code += "_looper();\n";
      }
      return code;
    }
  }, {
    key: "callTapsParallel",
    value: function callTapsParallel(_ref4) {
      var _this3 = this;
      var _onError2 = _ref4.onError,
        onResult = _ref4.onResult,
        onDone = _ref4.onDone,
        rethrowIfPossible = _ref4.rethrowIfPossible,
        _ref4$onTap = _ref4.onTap,
        onTap = _ref4$onTap === void 0 ? function (i, run) {
          return run();
        } : _ref4$onTap;
      if (this.options.taps.length <= 1) {
        return this.callTapsSeries({
          onError: _onError2,
          onResult: onResult,
          onDone: onDone,
          rethrowIfPossible: rethrowIfPossible
        });
      }
      var code = "";
      code += "do {\n";
      code += "var _counter = ".concat(this.options.taps.length, ";\n");
      if (onDone) {
        code += "var _done = (function() {\n";
        code += onDone();
        code += "});\n";
      }
      var _loop2 = function _loop2(i) {
        var done = function done() {
          if (onDone) return "if(--_counter === 0) _done();\n";else return "--_counter;";
        };
        var doneBreak = function doneBreak(skipDone) {
          if (skipDone || !onDone) return "_counter = 0;\n";else return "_counter = 0;\n_done();\n";
        };
        code += "if(_counter <= 0) break;\n";
        code += onTap(i, function () {
          return _this3.callTap(i, {
            onError: function onError(error) {
              var code = "";
              code += "if(_counter > 0) {\n";
              code += _onError2(i, error, done, doneBreak);
              code += "}\n";
              return code;
            },
            onResult: onResult && function (result) {
              var code = "";
              code += "if(_counter > 0) {\n";
              code += onResult(i, result, done, doneBreak);
              code += "}\n";
              return code;
            },
            onDone: !onResult && function () {
              return done();
            },
            rethrowIfPossible: rethrowIfPossible
          });
        }, done, doneBreak);
      };
      for (var i = 0; i < this.options.taps.length; i++) {
        _loop2(i);
      }
      code += "} while(false);\n";
      return code;
    }
  }, {
    key: "args",
    value: function args() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        before = _ref5.before,
        after = _ref5.after;
      var allArgs = this._args;
      if (before) allArgs = [before].concat(allArgs);
      if (after) allArgs = allArgs.concat(after);
      if (allArgs.length === 0) {
        return "";
      } else {
        return allArgs.join(", ");
      }
    }
  }, {
    key: "getTapFn",
    value: function getTapFn(idx) {
      return "_x[".concat(idx, "]");
    }
  }, {
    key: "getTap",
    value: function getTap(idx) {
      return "_taps[".concat(idx, "]");
    }
  }, {
    key: "getInterceptor",
    value: function getInterceptor(idx) {
      return "_interceptors[".concat(idx, "]");
    }
  }]);
  return HookCodeFactory;
}();
module.exports = HookCodeFactory;

/***/ }),

/***/ "./node_modules/tapable/lib/HookMap.js":
/*!*********************************************!*\
  !*** ./node_modules/tapable/lib/HookMap.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var util = __webpack_require__(/*! util */ "./node_modules/tapable/lib/util-browser.js");
var defaultFactory = function defaultFactory(key, hook) {
  return hook;
};
var HookMap = /*#__PURE__*/function () {
  function HookMap(factory) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    _classCallCheck(this, HookMap);
    this._map = new Map();
    this.name = name;
    this._factory = factory;
    this._interceptors = [];
  }
  _createClass(HookMap, [{
    key: "get",
    value: function get(key) {
      return this._map.get(key);
    }
  }, {
    key: "for",
    value: function _for(key) {
      var hook = this.get(key);
      if (hook !== undefined) {
        return hook;
      }
      var newHook = this._factory(key);
      var interceptors = this._interceptors;
      for (var i = 0; i < interceptors.length; i++) {
        newHook = interceptors[i].factory(key, newHook);
      }
      this._map.set(key, newHook);
      return newHook;
    }
  }, {
    key: "intercept",
    value: function intercept(interceptor) {
      this._interceptors.push(_extends({
        factory: defaultFactory
      }, interceptor));
    }
  }]);
  return HookMap;
}();
HookMap.prototype.tap = util.deprecate(function (key, options, fn) {
  return this.for(key).tap(options, fn);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");
HookMap.prototype.tapAsync = util.deprecate(function (key, options, fn) {
  return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");
HookMap.prototype.tapPromise = util.deprecate(function (key, options, fn) {
  return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");
module.exports = HookMap;

/***/ }),

/***/ "./node_modules/tapable/lib/MultiHook.js":
/*!***********************************************!*\
  !*** ./node_modules/tapable/lib/MultiHook.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && o[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var MultiHook = /*#__PURE__*/function () {
  function MultiHook(hooks) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    _classCallCheck(this, MultiHook);
    this.hooks = hooks;
    this.name = name;
  }
  _createClass(MultiHook, [{
    key: "tap",
    value: function tap(options, fn) {
      var _iterator = _createForOfIteratorHelper(this.hooks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var hook = _step.value;
          hook.tap(options, fn);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "tapAsync",
    value: function tapAsync(options, fn) {
      var _iterator2 = _createForOfIteratorHelper(this.hooks),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var hook = _step2.value;
          hook.tapAsync(options, fn);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      var _iterator3 = _createForOfIteratorHelper(this.hooks),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var hook = _step3.value;
          hook.tapPromise(options, fn);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "isUsed",
    value: function isUsed() {
      var _iterator4 = _createForOfIteratorHelper(this.hooks),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var hook = _step4.value;
          if (hook.isUsed()) return true;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return false;
    }
  }, {
    key: "intercept",
    value: function intercept(interceptor) {
      var _iterator5 = _createForOfIteratorHelper(this.hooks),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var hook = _step5.value;
          hook.intercept(interceptor);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }, {
    key: "withOptions",
    value: function withOptions(options) {
      return new MultiHook(this.hooks.map(function (h) {
        return h.withOptions(options);
      }), this.name);
    }
  }]);
  return MultiHook;
}();
module.exports = MultiHook;

/***/ }),

/***/ "./node_modules/tapable/lib/SyncBailHook.js":
/*!**************************************************!*\
  !*** ./node_modules/tapable/lib/SyncBailHook.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var SyncBailHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(SyncBailHookCodeFactory, _HookCodeFactory);
  function SyncBailHookCodeFactory() {
    _classCallCheck(this, SyncBailHookCodeFactory);
    return _callSuper(this, SyncBailHookCodeFactory, arguments);
  }
  _createClass(SyncBailHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        _onResult = _ref.onResult,
        resultReturns = _ref.resultReturns,
        onDone = _ref.onDone,
        rethrowIfPossible = _ref.rethrowIfPossible;
      return this.callTapsSeries({
        onError: function onError(i, err) {
          return _onError(err);
        },
        onResult: function onResult(i, result, next) {
          return "if(".concat(result, " !== undefined) {\n").concat(_onResult(result), ";\n} else {\n").concat(next(), "}\n");
        },
        resultReturns: resultReturns,
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  }]);
  return SyncBailHookCodeFactory;
}(HookCodeFactory);
var factory = new SyncBailHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC() {
  throw new Error("tapAsync is not supported on a SyncBailHook");
};
var TAP_PROMISE = function TAP_PROMISE() {
  throw new Error("tapPromise is not supported on a SyncBailHook");
};
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function SyncBailHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = SyncBailHook;
  hook.tapAsync = TAP_ASYNC;
  hook.tapPromise = TAP_PROMISE;
  hook.compile = COMPILE;
  return hook;
}
SyncBailHook.prototype = null;
module.exports = SyncBailHook;

/***/ }),

/***/ "./node_modules/tapable/lib/SyncHook.js":
/*!**********************************************!*\
  !*** ./node_modules/tapable/lib/SyncHook.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var SyncHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(SyncHookCodeFactory, _HookCodeFactory);
  function SyncHookCodeFactory() {
    _classCallCheck(this, SyncHookCodeFactory);
    return _callSuper(this, SyncHookCodeFactory, arguments);
  }
  _createClass(SyncHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone,
        rethrowIfPossible = _ref.rethrowIfPossible;
      return this.callTapsSeries({
        onError: function onError(i, err) {
          return _onError(err);
        },
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  }]);
  return SyncHookCodeFactory;
}(HookCodeFactory);
var factory = new SyncHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC() {
  throw new Error("tapAsync is not supported on a SyncHook");
};
var TAP_PROMISE = function TAP_PROMISE() {
  throw new Error("tapPromise is not supported on a SyncHook");
};
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function SyncHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = SyncHook;
  hook.tapAsync = TAP_ASYNC;
  hook.tapPromise = TAP_PROMISE;
  hook.compile = COMPILE;
  return hook;
}
SyncHook.prototype = null;
module.exports = SyncHook;

/***/ }),

/***/ "./node_modules/tapable/lib/SyncLoopHook.js":
/*!**************************************************!*\
  !*** ./node_modules/tapable/lib/SyncLoopHook.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var SyncLoopHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(SyncLoopHookCodeFactory, _HookCodeFactory);
  function SyncLoopHookCodeFactory() {
    _classCallCheck(this, SyncLoopHookCodeFactory);
    return _callSuper(this, SyncLoopHookCodeFactory, arguments);
  }
  _createClass(SyncLoopHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone,
        rethrowIfPossible = _ref.rethrowIfPossible;
      return this.callTapsLooping({
        onError: function onError(i, err) {
          return _onError(err);
        },
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  }]);
  return SyncLoopHookCodeFactory;
}(HookCodeFactory);
var factory = new SyncLoopHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC() {
  throw new Error("tapAsync is not supported on a SyncLoopHook");
};
var TAP_PROMISE = function TAP_PROMISE() {
  throw new Error("tapPromise is not supported on a SyncLoopHook");
};
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function SyncLoopHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var hook = new Hook(args, name);
  hook.constructor = SyncLoopHook;
  hook.tapAsync = TAP_ASYNC;
  hook.tapPromise = TAP_PROMISE;
  hook.compile = COMPILE;
  return hook;
}
SyncLoopHook.prototype = null;
module.exports = SyncLoopHook;

/***/ }),

/***/ "./node_modules/tapable/lib/SyncWaterfallHook.js":
/*!*******************************************************!*\
  !*** ./node_modules/tapable/lib/SyncWaterfallHook.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var Hook = __webpack_require__(/*! ./Hook */ "./node_modules/tapable/lib/Hook.js");
var HookCodeFactory = __webpack_require__(/*! ./HookCodeFactory */ "./node_modules/tapable/lib/HookCodeFactory.js");
var SyncWaterfallHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inherits(SyncWaterfallHookCodeFactory, _HookCodeFactory);
  function SyncWaterfallHookCodeFactory() {
    _classCallCheck(this, SyncWaterfallHookCodeFactory);
    return _callSuper(this, SyncWaterfallHookCodeFactory, arguments);
  }
  _createClass(SyncWaterfallHookCodeFactory, [{
    key: "content",
    value: function content(_ref) {
      var _this = this;
      var _onError = _ref.onError,
        onResult = _ref.onResult,
        resultReturns = _ref.resultReturns,
        rethrowIfPossible = _ref.rethrowIfPossible;
      return this.callTapsSeries({
        onError: function onError(i, err) {
          return _onError(err);
        },
        onResult: function onResult(i, result, next) {
          var code = "";
          code += "if(".concat(result, " !== undefined) {\n");
          code += "".concat(_this._args[0], " = ").concat(result, ";\n");
          code += "}\n";
          code += next();
          return code;
        },
        onDone: function onDone() {
          return onResult(_this._args[0]);
        },
        doneReturns: resultReturns,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  }]);
  return SyncWaterfallHookCodeFactory;
}(HookCodeFactory);
var factory = new SyncWaterfallHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC() {
  throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
var TAP_PROMISE = function TAP_PROMISE() {
  throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
function SyncWaterfallHook() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
  var hook = new Hook(args, name);
  hook.constructor = SyncWaterfallHook;
  hook.tapAsync = TAP_ASYNC;
  hook.tapPromise = TAP_PROMISE;
  hook.compile = COMPILE;
  return hook;
}
SyncWaterfallHook.prototype = null;
module.exports = SyncWaterfallHook;

/***/ }),

/***/ "./node_modules/tapable/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/tapable/lib/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


exports.__esModule = true;
exports.SyncHook = __webpack_require__(/*! ./SyncHook */ "./node_modules/tapable/lib/SyncHook.js");
exports.SyncBailHook = __webpack_require__(/*! ./SyncBailHook */ "./node_modules/tapable/lib/SyncBailHook.js");
exports.SyncWaterfallHook = __webpack_require__(/*! ./SyncWaterfallHook */ "./node_modules/tapable/lib/SyncWaterfallHook.js");
exports.SyncLoopHook = __webpack_require__(/*! ./SyncLoopHook */ "./node_modules/tapable/lib/SyncLoopHook.js");
exports.AsyncParallelHook = __webpack_require__(/*! ./AsyncParallelHook */ "./node_modules/tapable/lib/AsyncParallelHook.js");
exports.AsyncParallelBailHook = __webpack_require__(/*! ./AsyncParallelBailHook */ "./node_modules/tapable/lib/AsyncParallelBailHook.js");
exports.AsyncSeriesHook = __webpack_require__(/*! ./AsyncSeriesHook */ "./node_modules/tapable/lib/AsyncSeriesHook.js");
exports.AsyncSeriesBailHook = __webpack_require__(/*! ./AsyncSeriesBailHook */ "./node_modules/tapable/lib/AsyncSeriesBailHook.js");
exports.AsyncSeriesLoopHook = __webpack_require__(/*! ./AsyncSeriesLoopHook */ "./node_modules/tapable/lib/AsyncSeriesLoopHook.js");
exports.AsyncSeriesWaterfallHook = __webpack_require__(/*! ./AsyncSeriesWaterfallHook */ "./node_modules/tapable/lib/AsyncSeriesWaterfallHook.js");
exports.HookMap = __webpack_require__(/*! ./HookMap */ "./node_modules/tapable/lib/HookMap.js");
exports.MultiHook = __webpack_require__(/*! ./MultiHook */ "./node_modules/tapable/lib/MultiHook.js");

/***/ }),

/***/ "./node_modules/tapable/lib/util-browser.js":
/*!**************************************************!*\
  !*** ./node_modules/tapable/lib/util-browser.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


exports.deprecate = function (fn, msg) {
  var once = true;
  return function () {
    if (once) {
      console.warn("DeprecationWarning: " + msg);
      once = false;
    }
    return fn.apply(this, arguments);
  };
};

/***/ }),

/***/ "./node_modules/webpack/lib/logging/Logger.js":
/*!****************************************************!*\
  !*** ./node_modules/webpack/lib/logging/Logger.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var LogType = Object.freeze({
  error: ( /** @type {"error"} */"error"),
  // message, c style arguments
  warn: ( /** @type {"warn"} */"warn"),
  // message, c style arguments
  info: ( /** @type {"info"} */"info"),
  // message, c style arguments
  log: ( /** @type {"log"} */"log"),
  // message, c style arguments
  debug: ( /** @type {"debug"} */"debug"),
  // message, c style arguments

  trace: ( /** @type {"trace"} */"trace"),
  // no arguments

  group: ( /** @type {"group"} */"group"),
  // [label]
  groupCollapsed: ( /** @type {"groupCollapsed"} */"groupCollapsed"),
  // [label]
  groupEnd: ( /** @type {"groupEnd"} */"groupEnd"),
  // [label]

  profile: ( /** @type {"profile"} */"profile"),
  // [profileName]
  profileEnd: ( /** @type {"profileEnd"} */"profileEnd"),
  // [profileName]

  time: ( /** @type {"time"} */"time"),
  // name, time as [seconds, nanoseconds]

  clear: ( /** @type {"clear"} */"clear"),
  // no arguments
  status: ( /** @type {"status"} */"status") // message, arguments
});
exports.LogType = LogType;

/** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */

var LOG_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; })("webpack logger raw log method");
var TIMERS_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; })("webpack logger times");
var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; })("webpack logger aggregated times");
var WebpackLogger = /*#__PURE__*/function () {
  /**
   * @param {function(LogTypeEnum, any[]=): void} log log function
   * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger
   */
  function WebpackLogger(log, getChildLogger) {
    _classCallCheck(this, WebpackLogger);
    this[LOG_SYMBOL] = log;
    this.getChildLogger = getChildLogger;
  }
  _createClass(WebpackLogger, [{
    key: "error",
    value: function error() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      this[LOG_SYMBOL](LogType.error, args);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      this[LOG_SYMBOL](LogType.warn, args);
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      this[LOG_SYMBOL](LogType.info, args);
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this[LOG_SYMBOL](LogType.log, args);
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      this[LOG_SYMBOL](LogType.debug, args);
    }
  }, {
    key: "assert",
    value: function assert(assertion) {
      if (!assertion) {
        for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          args[_key6 - 1] = arguments[_key6];
        }
        this[LOG_SYMBOL](LogType.error, args);
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      this[LOG_SYMBOL](LogType.trace, ["Trace"]);
    }
  }, {
    key: "clear",
    value: function clear() {
      this[LOG_SYMBOL](LogType.clear);
    }
  }, {
    key: "status",
    value: function status() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      this[LOG_SYMBOL](LogType.status, args);
    }
  }, {
    key: "group",
    value: function group() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      this[LOG_SYMBOL](LogType.group, args);
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      this[LOG_SYMBOL](LogType.groupCollapsed, args);
    }
  }, {
    key: "groupEnd",
    value: function groupEnd() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      this[LOG_SYMBOL](LogType.groupEnd, args);
    }
  }, {
    key: "profile",
    value: function profile(label) {
      this[LOG_SYMBOL](LogType.profile, [label]);
    }
  }, {
    key: "profileEnd",
    value: function profileEnd(label) {
      this[LOG_SYMBOL](LogType.profileEnd, [label]);
    }
  }, {
    key: "time",
    value: function time(label) {
      this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
      this[TIMERS_SYMBOL].set(label, process.hrtime());
    }
  }, {
    key: "timeLog",
    value: function timeLog(label) {
      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) {
        throw new Error("No such label '".concat(label, "' for WebpackLogger.timeLog()"));
      }
      var time = process.hrtime(prev);
      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(label) {
      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) {
        throw new Error("No such label '".concat(label, "' for WebpackLogger.timeEnd()"));
      }
      var time = process.hrtime(prev);
      this[TIMERS_SYMBOL].delete(label);
      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
    }
  }, {
    key: "timeAggregate",
    value: function timeAggregate(label) {
      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) {
        throw new Error("No such label '".concat(label, "' for WebpackLogger.timeAggregate()"));
      }
      var time = process.hrtime(prev);
      this[TIMERS_SYMBOL].delete(label);
      this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();
      var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);
      if (current !== undefined) {
        if (time[1] + current[1] > 1e9) {
          time[0] += current[0] + 1;
          time[1] = time[1] - 1e9 + current[1];
        } else {
          time[0] += current[0];
          time[1] += current[1];
        }
      }
      this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
    }
  }, {
    key: "timeAggregateEnd",
    value: function timeAggregateEnd(label) {
      if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;
      var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
      if (time === undefined) return;
      this[TIMERS_AGGREGATES_SYMBOL].delete(label);
      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
    }
  }]);
  return WebpackLogger;
}();
exports.Logger = WebpackLogger;

/***/ }),

/***/ "./node_modules/webpack/lib/logging/createConsoleLogger.js":
/*!*****************************************************************!*\
  !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var _require = __webpack_require__(/*! ./Logger */ "./node_modules/webpack/lib/logging/Logger.js"),
  LogType = _require.LogType;

/** @typedef {import("../../declarations/WebpackOptions").FilterItemTypes} FilterItemTypes */
/** @typedef {import("../../declarations/WebpackOptions").FilterTypes} FilterTypes */
/** @typedef {import("./Logger").LogTypeEnum} LogTypeEnum */

/** @typedef {function(string): boolean} FilterFunction */

/**
 * @typedef {Object} LoggerConsole
 * @property {function(): void} clear
 * @property {function(): void} trace
 * @property {(...args: any[]) => void} info
 * @property {(...args: any[]) => void} log
 * @property {(...args: any[]) => void} warn
 * @property {(...args: any[]) => void} error
 * @property {(...args: any[]) => void=} debug
 * @property {(...args: any[]) => void=} group
 * @property {(...args: any[]) => void=} groupCollapsed
 * @property {(...args: any[]) => void=} groupEnd
 * @property {(...args: any[]) => void=} status
 * @property {(...args: any[]) => void=} profile
 * @property {(...args: any[]) => void=} profileEnd
 * @property {(...args: any[]) => void=} logTime
 */

/**
 * @typedef {Object} LoggerOptions
 * @property {false|true|"none"|"error"|"warn"|"info"|"log"|"verbose"} level loglevel
 * @property {FilterTypes|boolean} debug filter for debug logging
 * @property {LoggerConsole} console the console to log to
 */

/**
 * @param {FilterItemTypes} item an input item
 * @returns {FilterFunction} filter function
 */
var filterToFunction = function filterToFunction(item) {
  if (typeof item === "string") {
    var regExp = new RegExp("[\\\\/]".concat(item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&"), "([\\\\/]|$|!|\\?)"));
    return function (ident) {
      return regExp.test(ident);
    };
  }
  if (item && typeof item === "object" && typeof item.test === "function") {
    return function (ident) {
      return item.test(ident);
    };
  }
  if (typeof item === "function") {
    return item;
  }
  if (typeof item === "boolean") {
    return function () {
      return item;
    };
  }
};

/**
 * @enum {number}
 */
var LogLevel = {
  none: 6,
  false: 6,
  error: 5,
  warn: 4,
  info: 3,
  log: 2,
  true: 2,
  verbose: 1
};

/**
 * @param {LoggerOptions} options options object
 * @returns {function(string, LogTypeEnum, any[]): void} logging function
 */
module.exports = function (_ref) {
  var _ref$level = _ref.level,
    level = _ref$level === void 0 ? "info" : _ref$level,
    _ref$debug = _ref.debug,
    debug = _ref$debug === void 0 ? false : _ref$debug,
    console = _ref.console;
  var debugFilters = typeof debug === "boolean" ? [function () {
    return debug;
  }] : /** @type {FilterItemTypes[]} */[].concat(debug).map(filterToFunction);
  /** @type {number} */
  var loglevel = LogLevel["".concat(level)] || 0;

  /**
   * @param {string} name name of the logger
   * @param {LogTypeEnum} type type of the log entry
   * @param {any[]} args arguments of the log entry
   * @returns {void}
   */
  var logger = function logger(name, type, args) {
    var labeledArgs = function labeledArgs() {
      if (Array.isArray(args)) {
        if (args.length > 0 && typeof args[0] === "string") {
          return ["[".concat(name, "] ").concat(args[0])].concat(_toConsumableArray(args.slice(1)));
        } else {
          return ["[".concat(name, "]")].concat(_toConsumableArray(args));
        }
      } else {
        return [];
      }
    };
    var debug = debugFilters.some(function (f) {
      return f(name);
    });
    switch (type) {
      case LogType.debug:
        if (!debug) return;
        if (typeof console.debug === "function") {
          console.debug.apply(console, _toConsumableArray(labeledArgs()));
        } else {
          console.log.apply(console, _toConsumableArray(labeledArgs()));
        }
        break;
      case LogType.log:
        if (!debug && loglevel > LogLevel.log) return;
        console.log.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.info:
        if (!debug && loglevel > LogLevel.info) return;
        console.info.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.warn:
        if (!debug && loglevel > LogLevel.warn) return;
        console.warn.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.error:
        if (!debug && loglevel > LogLevel.error) return;
        console.error.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.trace:
        if (!debug) return;
        console.trace();
        break;
      case LogType.groupCollapsed:
        if (!debug && loglevel > LogLevel.log) return;
        if (!debug && loglevel > LogLevel.verbose) {
          if (typeof console.groupCollapsed === "function") {
            console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));
          } else {
            console.log.apply(console, _toConsumableArray(labeledArgs()));
          }
          break;
        }
      // falls through
      case LogType.group:
        if (!debug && loglevel > LogLevel.log) return;
        if (typeof console.group === "function") {
          console.group.apply(console, _toConsumableArray(labeledArgs()));
        } else {
          console.log.apply(console, _toConsumableArray(labeledArgs()));
        }
        break;
      case LogType.groupEnd:
        if (!debug && loglevel > LogLevel.log) return;
        if (typeof console.groupEnd === "function") {
          console.groupEnd();
        }
        break;
      case LogType.time:
        {
          if (!debug && loglevel > LogLevel.log) return;
          var ms = args[1] * 1000 + args[2] / 1000000;
          var msg = "[".concat(name, "] ").concat(args[0], ": ").concat(ms, " ms");
          if (typeof console.logTime === "function") {
            console.logTime(msg);
          } else {
            console.log(msg);
          }
          break;
        }
      case LogType.profile:
        if (typeof console.profile === "function") {
          console.profile.apply(console, _toConsumableArray(labeledArgs()));
        }
        break;
      case LogType.profileEnd:
        if (typeof console.profileEnd === "function") {
          console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));
        }
        break;
      case LogType.clear:
        if (!debug && loglevel > LogLevel.log) return;
        if (typeof console.clear === "function") {
          console.clear();
        }
        break;
      case LogType.status:
        if (!debug && loglevel > LogLevel.info) return;
        if (typeof console.status === "function") {
          if (args.length === 0) {
            console.status();
          } else {
            console.status.apply(console, _toConsumableArray(labeledArgs()));
          }
        } else {
          if (args.length !== 0) {
            console.info.apply(console, _toConsumableArray(labeledArgs()));
          }
        }
        break;
      default:
        throw new Error("Unexpected LogType ".concat(type));
    }
  };
  return logger;
};

/***/ }),

/***/ "./node_modules/webpack/lib/logging/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/webpack/lib/logging/runtime.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var _require = __webpack_require__(/*! tapable */ "./node_modules/tapable/lib/index.js"),
  SyncBailHook = _require.SyncBailHook;
var _require2 = __webpack_require__(/*! ./Logger */ "./node_modules/webpack/lib/logging/Logger.js"),
  Logger = _require2.Logger;
var createConsoleLogger = __webpack_require__(/*! ./createConsoleLogger */ "./node_modules/webpack/lib/logging/createConsoleLogger.js");

/** @type {createConsoleLogger.LoggerOptions} */
var currentDefaultLoggerOptions = {
  level: "info",
  debug: false,
  console: console
};
var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);

/**
 * @param {string} name name of the logger
 * @returns {Logger} a logger
 */
exports.getLogger = function (name) {
  return new Logger(function (type, args) {
    if (exports.hooks.log.call(name, type, args) === undefined) {
      currentDefaultLogger(name, type, args);
    }
  }, function (childName) {
    return exports.getLogger("".concat(name, "/").concat(childName));
  });
};

/**
 * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options
 * @returns {void}
 */
exports.configureDefaultLogger = function (options) {
  _extends(currentDefaultLoggerOptions, options);
  currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
};
exports.hooks = {
  log: new SyncBailHook(["origin", "type", "args"])
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
/*!********************************************!*\
  !*** ./client-src/modules/logger/index.js ***!
  \********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport default export from named module */ webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__; }
/* harmony export */ });
/* harmony import */ var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/lib/logging/runtime.js */ "./node_modules/webpack/lib/logging/runtime.js");

}();
var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;